clim_map[i,5]
clim_map = subset(clim_map,clim_map[,4]!="-9999")
clim_map[i,5]
eq = matrix(nr = nrow(clim_map), nc = 4)#
for(i in 1:nrow(clim_map)) eq[i,] = get_eq(ENV1 = clim_map[i,4],ENV2 = clim_map[i,5], pars)[1:4]#
#
# Clean negative values#
eq[eq<0]=0#
eq[eq>1]=1#
#
# Draw states#
draw = function(p) {#
	states = c("B","T","M","R")#
	draw = rmultinom(n=1,size=1,prob=p)#
	states[which(draw==1)]#
}#
#
States = apply(eq[,1:4],1,draw)
eq
eq[1,]
i
get_eq(ENV1 = clim_map[i,4],ENV2 = clim_map[i,5], pars)[1:4]
clim_map[i,4]
clim_map[i,5]
apply(clim_map,2,range)
hist(clim_map[,4])
hist(clim_map[,5])
clim_map[,4] = (clim_map[,4]-1.529991)/1.891697
clim_map[,5] = (clim_map[,5]*1000-1044.194)/132.858
eq = matrix(nr = nrow(clim_map), nc = 4)
for(i in 1:nrow(clim_map)) eq[i,] = get_eq(ENV1 = clim_map[i,4],ENV2 = clim_map[i,5], pars)[1:4]
apply(eq,2,range)
eq[,1]
hist(eq[,4])
eq[eq[,4]<0,4]=0
eq[eq[,4]==0,3]=1
eq[eq[,4]==0,2]=0
eq[eq[,4]==0,1]=0
# Draw states#
draw = function(p) {#
	states = c("B","T","M","R")#
	draw = rmultinom(n=1,size=1,prob=p)#
	states[which(draw==1)]#
}#
#
States = apply(eq[,1:4],1,draw)
dat = data.frame(x = clim_map$x, y = clim_map$y, States = States)
ggplot(dat) + # Ouvre la fenêtre ggplot2 et définit le jeu de données par défault#
  geom_raster(aes(x,y,fill=States, order = rev(States))) + # Définit la couche (raster) des états (T,B,M ou R)#
    scale_fill_brewer(palette="Spectral") + # Définit la palette de couleur#
    geom_polygon(data = subset(lakes,hole==FALSE), aes(x = long, y = lat, group = group),fill="lightskyblue",colour="dodgerblue4",size=0.1) + # Ajoute la couche des polygones ( de végétation) #
    geom_polygon(data = veg_zone, aes(x = long, y = lat, group = group),fill=NA,colour="grey90",size=0.3) + # Ajoute la couche des polygones (Zone de végétation) #
    scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0))+ # Élimine certains espaces indésirables dans les axes#
    coord_equal() + # Fait en sorte que les carrés du raster ne soit pas rectangulaire #
    xlab("Longitude") + ylab("Latitude")+ # Renomme les axes#
    theme(plot.title = element_text(lineheight=.8), panel.margin = unit(c(0.5,0,0,0),"in"),plot.margin = unit(c(0.1,0,0,0),"in")) # Ajuste les marges du graphiques
# Aggregate data#
dat = data.frame(x = clim_map$x, y = -clim_map$y, States = States)#
#
ggplot(dat) + # Ouvre la fenêtre ggplot2 et définit le jeu de données par défault#
  geom_raster(aes(x,y,fill=States, order = rev(States))) + # Définit la couche (raster) des états (T,B,M ou R)#
    scale_fill_brewer(palette="Spectral") + # Définit la palette de couleur#
    geom_polygon(data = subset(lakes,hole==FALSE), aes(x = long, y = lat, group = group),fill="lightskyblue",colour="dodgerblue4",size=0.1) + # Ajoute la couche des polygones ( de végétation) #
    geom_polygon(data = veg_zone, aes(x = long, y = lat, group = group),fill=NA,colour="grey90",size=0.3) + # Ajoute la couche des polygones (Zone de végétation) #
    scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0))+ # Élimine certains espaces indésirables dans les axes#
    coord_
dat = data.frame(x = clim_map$x, y = -clim_map$y, States = States)#
#
ggplot(dat) + # Ouvre la fenêtre ggplot2 et définit le jeu de données par défault#
  geom_raster(aes(x,y,fill=States, order = rev(States))) + # Définit la couche (raster) des états (T,B,M ou R)#
    scale_fill_brewer(palette="Spectral") + # Définit la palette de couleur#
    geom_polygon(data = subset(lakes,hole==FALSE), aes(x = long, y = lat, group = group),fill="lightskyblue",colour="dodgerblue4",size=0.1) + # Ajoute la couche des polygones ( de végétation) #
    geom_polygon(data = veg_zone, aes(x = long, y = lat, group = group),fill=NA,colour="grey90",size=0.3) + # Ajoute la couche des polygones (Zone de végétation) #
    scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0))+ # Élimine certains espaces indésirables dans les axes#
    coord_equal() + # Fait en sorte que les carrés du raster ne soit pas rectangulaire #
    xlab("Longitude") + ylab("Latitude")+ # Renomme les axes#
    theme(plot.title = element_text(lineheight=.8), panel.margin = unit(c(0.5,0,0,0),"in"),plot.margin = unit(c(0.1,0,0,0),"in")) # Ajuste les marges du graphiques
scale_fill_brewer(palette="Spectral")
apply(clim_map,2,range)
maxEig
cbind(P1[,1],maxEig)
i
i =1681
get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)[1:4]
get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)
get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)[1:4]
clim_space1[1681,]
3.5*1.9+1.5
3.*1.9+1.5
2*1.9+1.5
3*1.9+1.5
T = seq(-2,2,0.1)#
P = seq(-2,2,0.1)#
clim_space0 = expand.grid(T,P)#
clim_space1 = clim_space0+1#
#
P0 = matrix(nr = nrow(clim_space0), nc = 4)#
P1 = matrix(nr = nrow(clim_space0), nc = 4)#
EIG = matrix(nr = nrow(clim_space0), nc = 3)#
res = numeric(nrow(clim_space0))#
maxEig = numeric(nrow(clim_space0))#
#
# Compute initial conditions, final conditions and eigenvalues at final conditions#
for(i in 1:nrow(clim_space0)) {#
	P0[i,] 	= 	get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)[1:4]#
	res1 	= 	get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)#
	P1[i,] 	=  	res1[1:4]#
	EIG[i,] = 	res1[5:7]#
	maxEig[i] = max(EIG[i,])#
	N = P1[i,which.max(EIG[i,])]#
	N0 = P0[i,which.max(EIG[i,])]		#
	res[i] = log(N/N0)/maxEig[i]#
}
cbind(P1[,1],maxEig)
i = 1678
get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)[1:4]
get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)[1:4]
clim_space0 = expand.grid(T,P)#
clim_space1[,1] = clim_space0[,1]+1#
#
P0 = matrix(nr = nrow(clim_space0), nc = 4)#
P1 = matrix(nr = nrow(clim_space0), nc = 4)#
EIG = matrix(nr = nrow(clim_space0), nc = 3)#
res = numeric(nrow(clim_space0))#
maxEig = numeric(nrow(clim_space0))#
#
# Compute initial conditions, final conditions and eigenvalues at final conditions#
for(i in 1:nrow(clim_space0)) {#
	P0[i,] 	= 	get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)[1:4]#
	res1 	= 	get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)#
	P1[i,] 	=  	res1[1:4]#
	EIG[i,] = 	res1[5:7]#
	maxEig[i] = max(EIG[i,])#
	N = P1[i,which.max(EIG[i,])]#
	N0 = P0[i,which.max(EIG[i,])]		#
	res[i] = log(N/N0)/maxEig[i]#
}
cbind(P1[,1],maxEig)
range(maxEig)
i = 1599
get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)[1:4]
get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)[1:4]
clim_space1[i,]
clim_space2[i,]
T = seq(-2,2,0.1)#
P = seq(-2,2,0.1)#
clim_space0 = expand.grid(T,P)#
clim_space1[,1] = clim_space0[,1]+1
clim_space2[i,]
clim_space1[i,]
range(T)
range(P)
clim_space0 = expand.grid(T,P)
clim_space1 = expand.grid(T+1,P)
clim_space1[i,]
apply(clim_space0,2,range)
apply(clim_space1,2,range)
P0 = matrix(nr = nrow(clim_space0), nc = 4)#
P1 = matrix(nr = nrow(clim_space0), nc = 4)#
EIG = matrix(nr = nrow(clim_space0), nc = 3)#
res = numeric(nrow(clim_space0))#
maxEig = numeric(nrow(clim_space0))#
#
# Compute initial conditions, final conditions and eigenvalues at final conditions#
for(i in 1:nrow(clim_space0)) {#
	P0[i,] 		= 	get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)[1:4]#
	res1 		= 	get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)#
	P1[i,] 		=  	res1[1:4]#
	EIG[i,] 	= 	res1[5:7]#
	maxEig[i] = max(EIG[i,])#
	N = P1[i,which.max(EIG[i,])]#
	N0 = P0[i,which.max(EIG[i,])]		#
	res[i] = log(N/N0)/maxEig[i]#
}
ggplot(dat) + # Ouvre la fenêtre ggplot2 et définit le jeu de données par défault#
  geom_raster(aes(x,y,fill=States, order = rev(States))) + # Définit la couche (raster) des états (T,B,M ou R)#
    scale_fill_brewer(palette="Spectral") + # Définit la palette de couleur#
    geom_polygon(data = subset(lakes,hole==FALSE), aes(x = long, y = lat, group = group),fill="lightskyblue",colour="dodgerblue4",size=0.1) + # Ajoute la couche des polygones ( de végétation) #
    geom_polygon(data = veg_zone, aes(x = long, y = lat, group = group),fill=NA,colour="grey90",size=0.3) + # Ajoute la couche des polygones (Zone de végétation) #
    scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0))+ # Élimine certains espaces indésirables dans les axes#
    coord_equal() + # Fait en sorte que les carrés du raster ne soit pas rectangulaire #
    xlab("Longitude") + ylab("Latitude")+ # Renomme les axes#
    theme(plot.title = element_text(lineheight=.8), panel.margin = unit(c(0.5,0,0,0),"in"),plot.margin = unit(c(0.1,0,0,0),"in")) # Ajuste les marges du graphiques
T = seq(-2,2,0.01)#
P = seq(-2,2,0.01)#
clim_space = expand.grid(T,P)#
#
inv = matrix(nr = nrow(clim_space), nc = 2)#
prob = matrix(nr = nrow(clim_space), nc = 4)#
#
# Compute invasibility values#
for(i in 1:nrow(clim_space)) {#
  inv[i,] = get_inv(ENV1 = clim_space[i,1],ENV2 = clim_space[i,2], pars)#
  prob[i,] = get_eq(ENV1 = clim_space[i,1],ENV2 = clim_space[i,2], pars)[1:4]#
}#
#
# Draw states#
draw = function(p) {#
  states = c(1,2,3,0)#
  draw = rmultinom(n=1,size=1,prob=p)#
  states[which(draw==1)]#
}#
#
States = apply(prob,1,draw)#
#
# Plot the results#
Z = matrix(States,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
legend("center",legend = c("Régénération","Boréal","Tempéré","Mixte"),fill = c("black","darkcyan","orange","palegreen3"),bty = "n",horiz = TRUE,cex = 1)#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25, col = c("black","darkcyan","orange","palegreen3"))
T = seq(-2,2,0.1)#
P = seq(-2,2,0.1)#
clim_space = expand.grid(T,P)#
#
inv = matrix(nr = nrow(clim_space), nc = 2)#
prob = matrix(nr = nrow(clim_space), nc = 4)#
#
# Compute invasibility values#
for(i in 1:nrow(clim_space)) {#
  inv[i,] = get_inv(ENV1 = clim_space[i,1],ENV2 = clim_space[i,2], pars)#
  prob[i,] = get_eq(ENV1 = clim_space[i,1],ENV2 = clim_space[i,2], pars)[1:4]#
}#
#
# Draw states#
draw = function(p) {#
  states = c(1,2,3,0)#
  draw = rmultinom(n=1,size=1,prob=p)#
  states[which(draw==1)]#
}#
#
States = apply(prob,1,draw)#
#
# Plot the results#
Z = matrix(States,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
legend("center",legend = c("Régénération","Boréal","Tempéré","Mixte"),fill = c("black","darkcyan","orange","palegreen3"),bty = "n",horiz = TRUE,cex = 1)#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25, col = c("black","darkcyan","orange","palegreen3"))
Z = matrix(maxEig,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25)
maxEig
maxEig[maxEig>0]=0
Z = matrix(maxEig,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25)
range(maxEig)
hist(maxEig)
Z = log(abs(Z))
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25)
i = 1681
get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)[1:4]
get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)
get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)[1:4]
clim_space1[i,]
clim_space0[i,]
T = seq(-1.5,2,0.1)#
P = seq(-1.5,2,0.1)#
clim_space0 = expand.grid(T,P)#
clim_space1 = expand.grid(T+1,P)#
#
P0 = matrix(nr = nrow(clim_space0), nc = 4)#
P1 = matrix(nr = nrow(clim_space0), nc = 4)#
EIG = matrix(nr = nrow(clim_space0), nc = 3)#
res = numeric(nrow(clim_space0))#
maxEig = numeric(nrow(clim_space0))#
#
# Compute initial conditions, final conditions and eigenvalues at final conditions#
for(i in 1:nrow(clim_space0)) {#
	P0[i,] 		= 	get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)[1:4]#
	res1 		= 	get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)#
	P1[i,] 		=  	res1[1:4]#
	EIG[i,] 	= 	res1[5:7]#
	maxEig[i] = max(EIG[i,])#
	N = P1[i,which.max(EIG[i,])]#
	N0 = P0[i,which.max(EIG[i,])]		#
	res[i] = log(N/N0)/maxEig[i]#
}
range*maxEig
range(maxEig)
maxEig
clim_space1[i,1]
plot(clim_space1[,1],P1[,2])
clim_space1[i,]
ENV1 = 3
ENV2 = 2
# Compute the logit#
	logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV2 + ab3*ENV1^2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3#
    logit_alphat 	= at0 + at1*ENV1 + at2*ENV2 + at3*ENV1^2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3#
    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV2 + bb3*ENV1^2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3#
    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV2 + bt3*ENV1^2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3#
    logit_theta		= t0 + t1*ENV1 + t2*ENV2 + t3*ENV1^2 + t4*ENV2^2 + t5*ENV1^3 + t6*ENV2^3#
    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV2 + tt3*ENV1^2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3#
    logit_eps 		= e0  + e1*ENV1 + e2*ENV2  + e3*ENV1^2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3#
#
	# Back transform into probabilities#
	backProba <- function(x) exp(x)/(1+exp(x))#
	alphaB 	= backProba(logit_alphab)#
	alphaT 	= backProba(logit_alphat)#
	theta 	= backProba(logit_theta)#
	thetaT 	= backProba(logit_thetat)#
	betaB 	= backProba(logit_betab)#
	betaT 	= backProba(logit_betat)#
	eps 	= backProba(logit_eps)
alphaB
alphaT
eps
# Vector of parameters to feed stode#
	model_pars = c(alphaB = alphaB, alphaT = alphaT, betaB = betaB, betaT = betaT, theta = theta, thetaT = thetaT, eps = eps)	#
#
	# Compute the equilibrium#
	y = c(B = 1/3,  T = 1/3, M = 1/3)#
#	eq = runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))[[1]]#
	eq = stode(y=y, func=model, parms=model_pars,positive = TRUE)[[1]]
eq
# Compute the equilibrium#
	y = c(B = 0.01,  T = 0.01, M = 0.01)#
#	eq = runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))[[1]]#
	eq = stode(y=y, func=model, parms=model_pars,positive = TRUE)[[1]]
eq
# Compute the equilibrium#
	y = c(B = 0.2,  T = 0.2, M = 0.2)#
#	eq = runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))[[1]]#
	eq = stode(y=y, func=model, parms=model_pars,positive = TRUE)[[1]]
eq
func
# Compute the Jacobian#
	J = jacobian.full(y=eq,func=model,parms=pars)
as.numeric(eigen(J)$values)
# Compute the equilibrium#
	y = c(B = 1/3,  T = 1/3, M = 1/3)#
#	eq = runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))[[1]]#
	eq = stode(y=y, func=model, parms=model_pars,positive = TRUE)[[1]]#
#
	# Compute the Jacobian#
	J = jacobian.full(y=eq,func=model,parms=pars)
as.numeric(eigen(J)$values)
eq
P1[i,]
get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)
i
res[i]
maxEig[i]
max(res1[5:7])
res1[5:7]
res1 		= 	get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)
res1
P1[i,] 		=  	res1[1:4]
max(res1[5:7])
# Compute initial conditions, final conditions and eigenvalues at final conditions#
for(i in 1:nrow(clim_space0)) {#
	P0[i,] 		= 	get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)[1:4]#
	res1 		= 	get_eq(ENV1 = clim_space1[i,1],ENV2 = clim_space1[i,2], pars)#
	P1[i,] 		=  	res1[1:4]#
	EIG[i,] 	= 	res1[5:7]#
	maxEig[i] = max(res1[5:7])#
	N = P1[i,which.max(EIG[i,])]#
	N0 = P0[i,which.max(EIG[i,])]		#
	res[i] = log(N/N0)/maxEig[i]#
}
maxEig
range(maxEig)
# Plot the results#
Z = matrix(maxEig,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25)
hist(maxEig)
hist(maxEig)
hist(log(abs(maxEig)))
hist(maxEig)
cbind(P1,maxEig)
i = 1188
P1[i,]
P0[i,]
clim_space1[i,]
ENV1 = 3
ENV2 = 1.7
# Compute the logit#
	logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV2 + ab3*ENV1^2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3#
    logit_alphat 	= at0 + at1*ENV1 + at2*ENV2 + at3*ENV1^2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3#
    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV2 + bb3*ENV1^2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3#
    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV2 + bt3*ENV1^2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3#
    logit_theta		= t0 + t1*ENV1 + t2*ENV2 + t3*ENV1^2 + t4*ENV2^2 + t5*ENV1^3 + t6*ENV2^3#
    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV2 + tt3*ENV1^2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3#
    logit_eps 		= e0  + e1*ENV1 + e2*ENV2  + e3*ENV1^2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3#
#
	# Back transform into probabilities#
	backProba <- function(x) exp(x)/(1+exp(x))#
	alphaB 	= backProba(logit_alphab)#
	alphaT 	= backProba(logit_alphat)#
	theta 	= backProba(logit_theta)#
	thetaT 	= backProba(logit_thetat)#
	betaB 	= backProba(logit_betab)#
	betaT 	= backProba(logit_betat)#
	eps 	= backProba(logit_eps)#
#
	# Vector of parameters to feed stode#
	model_pars = c(alphaB = alphaB, alphaT = alphaT, betaB = betaB, betaT = betaT, theta = theta, thetaT = thetaT, eps = eps)	#
#
	# Compute the equilibrium#
	y = c(B = 1/3,  T = 1/3, M = 1/3)#
#	eq = runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))[[1]]#
	eq = stode(y=y, func=model, parms=model_pars,positive = TRUE)[[1]]#
#
	# Compute the Jacobian#
	J = jacobian.full(y=eq,func=model,parms=pars)
jacobian.full(y=eq,func=model,parms=pars)
as.numeric(eigen(J)$values)
eq
eq = runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))[[1]]
eq
runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))
runsteady(y=y, func=model, parms=model_pars,times = c(0,100000))
eq
J = jacobian.full(y=eq,func=model,parms=pars)#
	# Compute the largest eigen value#
	Eigs = as.numeric(eigen(J)$values)
Eigs
runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))[[1]]
P=1.69
# Compute the logit#
	logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV2 + ab3*ENV1^2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3#
    logit_alphat 	= at0 + at1*ENV1 + at2*ENV2 + at3*ENV1^2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3#
    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV2 + bb3*ENV1^2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3#
    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV2 + bt3*ENV1^2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3#
    logit_theta		= t0 + t1*ENV1 + t2*ENV2 + t3*ENV1^2 + t4*ENV2^2 + t5*ENV1^3 + t6*ENV2^3#
    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV2 + tt3*ENV1^2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3#
    logit_eps 		= e0  + e1*ENV1 + e2*ENV2  + e3*ENV1^2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3#
#
	# Back transform into probabilities#
	backProba <- function(x) exp(x)/(1+exp(x))#
	alphaB 	= backProba(logit_alphab)#
	alphaT 	= backProba(logit_alphat)#
	theta 	= backProba(logit_theta)#
	thetaT 	= backProba(logit_thetat)#
	betaB 	= backProba(logit_betab)#
	betaT 	= backProba(logit_betat)#
	eps 	= backProba(logit_eps)#
#
	# Vector of parameters to feed stode#
	model_pars = c(alphaB = alphaB, alphaT = alphaT, betaB = betaB, betaT = betaT, theta = theta, thetaT = thetaT, eps = eps)	#
#
	# Compute the equilibrium#
	y = c(B = 0.25,  T = 0.25, M = 0.25)#
#	eq = runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))[[1]]#
	eq = stode(y=y, func=model, parms=model_pars,positive = TRUE)[[1]]#
#
	# Compute the Jacobian#
	J = jacobian.full(y=eq,func=model,parms=pars)#
	# Compute the largest eigen value#
	Eigs = as.numeric(eigen(J)$values)
Eigs
ENV2
ENV2=1.69
# Compute the logit#
	logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV2 + ab3*ENV1^2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3#
    logit_alphat 	= at0 + at1*ENV1 + at2*ENV2 + at3*ENV1^2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3#
    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV2 + bb3*ENV1^2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3#
    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV2 + bt3*ENV1^2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3#
    logit_theta		= t0 + t1*ENV1 + t2*ENV2 + t3*ENV1^2 + t4*ENV2^2 + t5*ENV1^3 + t6*ENV2^3#
    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV2 + tt3*ENV1^2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3#
    logit_eps 		= e0  + e1*ENV1 + e2*ENV2  + e3*ENV1^2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3#
#
	# Back transform into probabilities#
	backProba <- function(x) exp(x)/(1+exp(x))#
	alphaB 	= backProba(logit_alphab)#
	alphaT 	= backProba(logit_alphat)#
	theta 	= backProba(logit_theta)#
	thetaT 	= backProba(logit_thetat)#
	betaB 	= backProba(logit_betab)#
	betaT 	= backProba(logit_betat)#
	eps 	= backProba(logit_eps)#
#
	# Vector of parameters to feed stode#
	model_pars = c(alphaB = alphaB, alphaT = alphaT, betaB = betaB, betaT = betaT, theta = theta, thetaT = thetaT, eps = eps)	#
#
	# Compute the equilibrium#
	y = c(B = 0.25,  T = 0.25, M = 0.25)#
#	eq = runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))[[1]]#
	eq = stode(y=y, func=model, parms=model_pars,positive = TRUE)[[1]]#
#
	# Compute the Jacobian#
	J = jacobian.full(y=eq,func=model,parms=pars)#
	# Compute the largest eigen value#
	Eigs = as.numeric(eigen(J)$values)
Eigs
ENV2 = 1.6
# Compute the logit#
	logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV2 + ab3*ENV1^2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3#
    logit_alphat 	= at0 + at1*ENV1 + at2*ENV2 + at3*ENV1^2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3#
    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV2 + bb3*ENV1^2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3#
    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV2 + bt3*ENV1^2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3#
    logit_theta		= t0 + t1*ENV1 + t2*ENV2 + t3*ENV1^2 + t4*ENV2^2 + t5*ENV1^3 + t6*ENV2^3#
    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV2 + tt3*ENV1^2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3#
    logit_eps 		= e0  + e1*ENV1 + e2*ENV2  + e3*ENV1^2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3#
#
	# Back transform into probabilities#
	backProba <- function(x) exp(x)/(1+exp(x))#
	alphaB 	= backProba(logit_alphab)#
	alphaT 	= backProba(logit_alphat)#
	theta 	= backProba(logit_theta)#
	thetaT 	= backProba(logit_thetat)#
	betaB 	= backProba(logit_betab)#
	betaT 	= backProba(logit_betat)#
	eps 	= backProba(logit_eps)#
#
	# Vector of parameters to feed stode#
	model_pars = c(alphaB = alphaB, alphaT = alphaT, betaB = betaB, betaT = betaT, theta = theta, thetaT = thetaT, eps = eps)	#
#
	# Compute the equilibrium#
	y = c(B = 0.25,  T = 0.25, M = 0.25)#
#	eq = runsteady(y=y, func=model, parms=model_pars,times = c(0,10000))[[1]]#
	eq = stode(y=y, func=model, parms=model_pars,positive = TRUE)[[1]]#
#
	# Compute the Jacobian#
	J = jacobian.full(y=eq,func=model,parms=pars)#
	# Compute the largest eigen value#
	Eigs = as.numeric(eigen(J)$values)
Eigs
# Plot the results#
Z = matrix(maxEig,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25)
hist(maxEig)
hist(maxEig)
maxEig[maxEig>-0.6]=-0.6
hist(maxEig)
# Plot the results#
Z = matrix(maxEig,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25)
plot(clim_space1[,1],maxEig)
plot(clim_space1[,1],maxEig)
# BIOMASS#
H =  5		# Harfang#
R =	15		# Renard#
L = 100		# Lemmings#
O = 10000	# Oie#
A = 20000	# Arbustes#
P = 140000	# Herbacées#
#
# MORTALITÉ#
b_H = 0.3#
b_R = 0.2#
b_L = 0.1#
b_O = 0.1#
#
# EFFICACITÉ DE CONVERSION#
e_H = 0.45#
e_R = 0.45#
e_L = 0.8#
e_O = 0.6#
#
# RÉPARTITION DE LA DIÈTE#
w_RH = 0.1#
w_LH = 0.9#
w_LR = 0.7#
w_OR = 0.3#
w_AL = 0.2#
w_PL = 0.8#
#
# CAPACITÉ DE SUPPORT#
K_A = 30000#
K_P = 200000#
#
# CALCULS DES FLUX#
phi_H = b_H*H#
phi_RH = w_RH * phi_H#
phi_LH = w_LH * phi_H#
#
phi_R = b_R*R + phi_RH/e_H#
phi_LR = w_LR * phi_R#
phi_OR = w_OR * phi_R#
#
phi_L = b_L*L + phi_LR/e_R + phi_LH/e_H#
phi_AL = w_AL * phi_L#
phi_PL = w_PL * phi_L#
#
phi_O = b_O*O + phi_OR/e_R#
phi_PO = phi_O #
#
phi_A = phi_AL/e_L#
phi_P = phi_PL/e_L + phi_PO/e_O#
#
# CALCUL DU TAUX DE CROISSANCE CHEZ LES PLANTES#
r_A = phi_A/A*(1-A/K_A)^-1#
r_P = phi_P/P*(1-P/K_P)^-1#
#
# CALCUL DES COEFFICIENTS D'INTERACTIONS#
a_HR = phi_RH/R/H#
a_RH = - a_HR/e_H#
#
a_HL = phi_LH/L/H#
a_LH = - a_HL/e_H#
#
a_RL = phi_LR/R/L#
a_LR = - a_RL/e_R#
#
a_RO = phi_OR/O/R#
a_OR = - a_RO/e_R#
#
a_LA = phi_AL/A/L#
a_AL = - a_LA/e_L#
#
a_LP = phi_PL/P/L#
a_PL = - a_LP/e_L#
#
a_OP = phi_PO/O/P#
a_PO = -a_OP/e_O#
#
a_AA = -r_A/K_A#
a_PP = -r_P/K_P
a_HR*R*H + a_HL*L*H - b_H*H
plot(clim_space1[,1],maxEig)
T = seq(-1.5,2,0.1)#
P = seq(-1.5,2,0.1)#
clim_space0 = expand.grid(T,P)#
clim_space1 = expand.grid(T+1,P)#
#
P = matrix(nr = nrow(clim_space0), nc = 4)#
EIG = matrix(nr = nrow(clim_space0), nc = 3)#
res = numeric(nrow(clim_space0))#
maxEig = numeric(nrow(clim_space0))#
#
# Compute initial conditions, final conditions and eigenvalues at final conditions#
for(i in 1:nrow(clim_space0)) {#
	res 		= 	get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)#
	P[i,] 		=  	res[1:4]#
	maxEig[i] = max(res[5:7])#
}#
# solution pour TR: -no/lambda
T = seq(-2,2,0.1)#
P = seq(-2,2,0.1)#
clim_space0 = expand.grid(T,P)#
clim_space1 = expand.grid(T+1,P)#
#
P = matrix(nr = nrow(clim_space0), nc = 4)#
EIG = matrix(nr = nrow(clim_space0), nc = 3)#
res = numeric(nrow(clim_space0))#
maxEig = numeric(nrow(clim_space0))#
#
# Compute initial conditions, final conditions and eigenvalues at final conditions#
for(i in 1:nrow(clim_space0)) {#
	res 		= 	get_eq(ENV1 = clim_space0[i,1],ENV2 = clim_space0[i,2], pars)#
	P[i,] 		=  	res[1:4]#
	maxEig[i] = max(res[5:7])#
}#
# solution pour TR: -no/lambda
# Plot the results#
Z = matrix(maxEig,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25)
maxEig
range(maxEig)
T
p=P
P = seq(-2,2,0.1)
# Plot the results#
Z = matrix(maxEig,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25)
plot(clim_space0[,1],maxEig)
# Plot the results#
Z = matrix(maxEig,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25)
z=1
prob = matrix(nr = nrow(clim_future), nc = 4)
pred_STM = matrix(nr = nrow(clim_future), nc=4)
prob = matrix(nr = nrow(clim_map), nc = 4)
pred_STM = matrix(nr = nrow(clim_map), nc=4)
prob[z,] = get_eq(ENV1 = clim_map[z,4],ENV2 = clim_map[z,5], pars)[1:4]
prob[z,]
pred_STM[[z]] = sim_ODEs(p0 = prob[z,], climSeq = climSeq[[z]], pars)
# Create the cimate sequences #
climSeqList=list()#
for(i in 1:nrow(clim_map)) {#
  Tseq = seq(clim_map[i,1],clim_map[i,1]+2,by = 2/(nsteps-1))#
  Pseq = numeric(nsteps) + clim_map[i,2]#
  climSeq[[i]] = cbind(Tseq,Pseq)#
}
# Create the cimate sequences #
climSeqList=list()#
for(i in 1:nrow(clim_map)) {#
  Tseq = seq(clim_map[i,1],clim_map[i,1]+2,by = 2/(nsteps-1))#
  Pseq = numeric(nsteps) + clim_map[i,2]#
  climSeq[[i]] = cbind(Tseq,Pseq)#
}
# Create the cimate sequences #
climSeqList=list()#
for(i in 1:nrow(clim_map)) {#
  Tseq = seq(clim_map[i,1],clim_map[i,1]+2,by = 2/(nsteps-1))#
  Pseq = numeric(nsteps) + clim_map[i,2]#
  climSeqList[[i]] = cbind(Tseq,Pseq)#
}
climSeqList[[z]]
i=1
clim_map[i,2]
head(clim_map)
# Create the cimate sequences #
climSeqList=list()#
for(i in 1:nrow(clim_map)) {#
  Tseq = seq(clim_map[i,4],clim_map[i,4]+2,by = 2/(nsteps-1))#
  Pseq = numeric(nsteps) + clim_map[i,5]#
  climSeqList[[i]] = cbind(Tseq,Pseq)#
}
climSeqList[[z]]
i = 1
clim_map[i,5]
hist(clim_map[,5])
clim_map = read.csv("data/pastClimate_grid.csv")#
clim_map = subset(clim_map,clim_map[,4]!="-9999")
hist(clim_map[,5])
clim_map[,4] = (clim_map[,4]-1.529991)/1.891697#
clim_map[,5] = (clim_map[,5]*1000-1044.194)/132.858
hist(clim_map[,5])
climSeqList[[1]]
Seq = climSeqList[[z]]
Seq
climSeq = Seq
# Plot the results#
Z = matrix(States,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
legend("center",legend = c("Régénération","Boréal","Tempéré","Mixte"),fill = c("black","darkcyan","orange","palegreen3"),bty = "n",horiz = TRUE,cex = 1)#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25, col = c("black","darkcyan","orange","palegreen3"))
source("4-init_params_newData.R")
source("4-init_params_newData.R")
data = read.csv("transitionsFourState.csv")#
head(data)#
dim(data)#
data$annual_mean_temp = apply(data[,c("annual_mean_temp1", "annual_mean_temp2")], 1, mean)#
data$annual_pp = apply(data[,c("annual_pp1", "annual_pp2")], 1, mean)
bins = floor(data$annual_mean_temp)
for(i in 1:length(table(bins))) dens.tp[bins==names(bins)[i]]=dens.bins[i]
data = read.csv("transitionsFourState.csv")
names(data)
dim(data)
# ----------------------#
### choice of variables#
# ----------------------#
selectedVars = c("annual_mean_temp",  "annual_pp")#
#
datSel = data[,c("state",selectedVars)]#
#
rm(data)
data = read.csv("transitionsFourState.csv")#
#data = read.csv("../STModel-Data/out_files/statesFourState.csv")#
head(data)#
dim(data)#
# ----------------------#
### choice of variables#
# ----------------------#
selectedVars = c("annual_mean_temp",  "annual_pp")#
#
datSel = data[,c("state2",selectedVars)]#
#
rm(data)#
# ----------------------#
# Clean data#
# ---------------------#
#
# Clean Undefined state#
str(datSel)#
datSel_wo_U <- subset(datSel, state != "U")#
datSel_wo_U$state <- droplevels(datSel_wo_U$state)#
#
# ----------------------
data = read.csv("transitionsFourState.csv")#
#data = read.csv("../STModel-Data/out_files/statesFourState.csv")#
head(data)#
dim(data)#
# ----------------------#
### choice of variables#
# ----------------------#
selectedVars = c("annual_mean_temp",  "annual_pp")#
#
datSel = data[,c("state2",selectedVars)]
names(data)
data = read.csv("transitionsFourState.csv")#
#data = read.csv("../STModel-Data/out_files/statesFourState.csv")#
head(data)#
dim(data)#
# ----------------------#
### choice of variables#
# ----------------------#
selectedVars = c("annual_mean_temp2",  "annual_pp")#
#
datSel = data[,c("state2",selectedVars)]#
#
rm(data)
data = read.csv("transitionsFourState.csv")#
#data = read.csv("../STModel-Data/out_files/statesFourState.csv")#
head(data)#
dim(data)#
# ----------------------#
### choice of variables#
# ----------------------#
selectedVars = c("annual_mean_temp2",  "annual_pp2")#
#
datSel = data[,c("state2",selectedVars)]
rm(data)#
# ----------------------#
# Clean data#
# ---------------------#
#
# Clean Undefined state#
str(datSel)#
datSel_wo_U <- subset(datSel, state != "U")#
datSel_wo_U$state <- droplevels(datSel_wo_U$state)#
#
# ----------------
datSel_wo_U <- subset(datSel, state2 != "U")
datSel_wo_U$state <- droplevels(datSel_wo_U$state2)
# ----------------------#
# models #
# ----------------------#
# evaluation statistics#
HK <- function (Pred, Obs) #
{#
#
	Misc = table(Pred, Obs)#
    if (nrow(Misc)!=ncol(Misc)) stop("wrong misclassification table")#
    Misc <- unclass(Misc)#
    k  <- ncol(Misc)#
    Nobs <- apply(Misc, 2, sum)#
    Npred <- apply(Misc, 1, sum)#
    N <- sum(Nobs)#
   HK <- (sum(diag(Misc))/N - sum(as.numeric(Nobs)*as.numeric(Npred))/N/N ) / ( 1 - sum(as.numeric(Nobs)*as.numeric(Nobs))/N/N )#
#
    return(HK)#
}
# cross validation - separation of the dataset#
sampl = sample(1:nrow(datSel_wo_U), 2*nrow(datSel_wo_U)/3)#
calib = datSel_wo_U[sampl,c("state2",selectedVars)] #
valid = datSel_wo_U[-sampl,c("state2",selectedVars)]
# random Forest#
# calib#
library(randomForest)#
rs = runif(1,0,1)#
set.seed(rs)#
SDM2 = randomForest(state ~ . , data = calib, ntree = 500)#
SDM2#
save(SDM2,rs,sampl,file= "RandomForest_temp.rObj")#
# valid#
set.seed(rs)#
pred2 = predict(SDM2,new=datSel_wo_U,"response", OOB=TRUE)#
(HK2 = HK(pred2[-sampl], valid$state))
# random Forest#
# calib#
library(randomForest)#
rs = runif(1,0,1)#
set.seed(rs)#
SDM2 = randomForest(state2 ~ . , data = calib, ntree = 500)#
SDM2#
save(SDM2,rs,sampl,file= "RandomForest_temp.rObj")
# ----------------------#
# projection #
# ----------------------#
## ----recap data#
#load("../data/Multinom_temp.rObj")#
load("../data/RandomForest_temp.rObj")#
selectedVars = c("annual_mean_temp",  "annual_pp")#
#---------------#
#
dataProj = read.csv("transitionsFourState.csv")#
head(dataProj)#
#
# means between climates of year of state 0 and year of state 1#
dataProj$annual_mean_temp = apply(dataProj[,c("annual_mean_temp1", "annual_mean_temp2")], 1, mean)#
dataProj$annual_pp = apply(dataProj[,c("annual_pp1", "annual_pp2")], 1, mean)#
#
datProjSel = dataProj[,selectedVars]#
#
# projection#
set.seed(rs)#
projProba = predict(SDM2,new=datProjSel,"prob", OOB=TRUE)#
head(projProba)
dataProj$annual_mean_temp = apply(dataProj[,c("annual_mean_temp1", "annual_mean_temp2")], 1, mean)
dataProj$annual_pp = apply(dataProj[,c("annual_pp1", "annual_pp2")], 1, mean)
datProjSel = dataProj[,selectedVars]
set.seed(rs)
projProba = predict(SDM2,new=datProjSel,"prob", OOB=TRUE)
# means between climates of year of state 0 and year of state 1#
dataProj$annual_mean_temp2 = apply(dataProj[,c("annual_mean_temp1", "annual_mean_temp2")], 1, mean)#
dataProj$annual_pp2 = apply(dataProj[,c("annual_pp1", "annual_pp2")], 1, mean)#
#
datProjSel = dataProj[,selectedVars]#
#
# projection#
set.seed(rs)#
projProba = predict(SDM2,new=datProjSel,"prob", OOB=TRUE)#
head(projProba)
names(datProjSel)
datSel
seqselectVars
selectedVars = c("annual_mean_temp2",  "annual_pp2")#
#---------------#
#
dataProj = read.csv("transitionsFourState.csv")#
head(dataProj)#
#
# means between climates of year of state 0 and year of state 1#
dataProj$annual_mean_temp2 = apply(dataProj[,c("annual_mean_temp1", "annual_mean_temp2")], 1, mean)#
dataProj$annual_pp2 = apply(dataProj[,c("annual_pp1", "annual_pp2")], 1, mean)#
#
datProjSel = dataProj[,selectedVars]
# projection#
set.seed(rs)#
projProba = predict(SDM2,new=datProjSel,"prob", OOB=TRUE)#
head(projProba)
dim(projProba)
write.table(projProba, file = "projection_neigbor_rf_temp.txt", quote=F, row.names=FALSE)
getwd()
library(GenSA)
?GenSA
source("scripts/read_pars.R")#
pars = as.list(read_pars("data/pars.txt"))#
#
################################
# PLOT THE CLIMATIC SPACE#
#
source("scripts/get_eq.R")#
#
T = seq(-2,2,0.01)#
P = seq(-2,2,0.01)#
clim_space = expand.grid(T,P)#
#
inv = matrix(nr = nrow(clim_space), nc = 2)#
prob = matrix(nr = nrow(clim_space), nc = 4)#
#
# Compute invasibility values#
for(i in 1:nrow(clim_space)) {#
  inv[i,] = get_inv(ENV1 = clim_space[i,1],ENV2 = clim_space[i,2], pars)#
  prob[i,] = get_eq(ENV1 = clim_space[i,1],ENV2 = clim_space[i,2], pars)[1:4]#
}#
#
# Draw states#
draw = function(p) {#
  states = c(1,2,3,0)#
  draw = rmultinom(n=1,size=1,prob=p)#
  states[which(draw==1)]#
}#
#
States = apply(prob,1,draw)#
#
# Plot the results#
Z = matrix(States,nr = length(T), nc = length(P))#
quartz(width = 6, height = 6)#
layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))#
par(mar=c(0,0,0,0))#
plot(1, type = "n", axes=FALSE, xlab="", ylab="")#
legend("center",legend = c("Régénération","Boréal","Tempéré","Mixte"),fill = c("black","darkcyan","orange","palegreen3"),bty = "n",horiz = TRUE,cex = 1)#
par(mar=c(5,5,0,2))#
image(T*1.891697+1.529991 ,P*132.858+1044.194,Z,xlab = "Température moyenne annuelle", ylab = "Précipitations annuelles (mm)", cex.lab = 1.5, cex.axis = 1.25, col = c("black","darkcyan","orange","palegreen3"))
require("ggplot2")#
require("maptools")#
require("grid")#
#
# Shapefiles #
lakes  <- readShapePoly("shapes/water_area_qc.shp") # Lecture du shapefile#
lakes@proj4string  <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0") # Définit la projection géographique#
lakes  <- fortify(lakes) # Transforme les polygones vers un dataframe compréhensible pour ggplot2#
veg_zone  <- readShapePoly("shapes/zone_veg.shp") # Lecture du shapefile#
veg_zone@proj4string  <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0") # Définit la projection géographique#
veg_zone  <- fortify(veg_zone) # Transforme les polygones vers un dataframe compréhensible pour ggplot2#
theme_set(theme_grey(base_size = 18)) # Augmente la taille de la police par défault des figures (ggplot2)#
#
# Climate data#
clim_map = read.csv("data/pastClimate_grid.csv")#
clim_map = subset(clim_map,clim_map[,4]!="-9999")#
clim_map[,4] = (clim_map[,4]-1.529991)/1.891697#
clim_map[,5] = (clim_map[,5]*1000-1044.194)/132.858#
#
eq = matrix(nr = nrow(clim_map), nc = 4)#
for(i in 1:nrow(clim_map)) eq[i,] = get_eq(ENV1 = clim_map[i,4],ENV2 = clim_map[i,5], pars)[1:4]#
#
# Clean negative values#
eq[eq<0]=0#
eq[eq>1]=1#
#
# Draw states#
draw = function(p) {#
	states = c("B","T","M","R")#
	draw = rmultinom(n=1,size=1,prob=p)#
	states[which(draw==1)]#
}#
#
States = apply(eq[,1:4],1,draw)#
#
# Aggregate data#
dat = data.frame(x = clim_map$x, y = -clim_map$y, States = States)#
#
ggplot(dat) + # Ouvre la fenêtre ggplot2 et définit le jeu de données par défault#
  geom_raster(aes(x,y,fill=States, order = rev(States))) + # Définit la couche (raster) des états (T,B,M ou R)#
    scale_fill_brewer(palette="Spectral") + # Définit la palette de couleur#
    geom_polygon(data = subset(lakes,hole==FALSE), aes(x = long, y = lat, group = group),fill="lightskyblue",colour="dodgerblue4",size=0.1) + # Ajoute la couche des polygones ( de végétation) #
    geom_polygon(data = veg_zone, aes(x = long, y = lat, group = group),fill=NA,colour="grey90",size=0.3) + # Ajoute la couche des polygones (Zone de végétation) #
    scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0))+ # Élimine certains espaces indésirables dans les axes#
    coord_equal() + # Fait en sorte que les carrés du raster ne soit pas rectangulaire #
    xlab("Longitude") + ylab("Latitude")+ # Renomme les axes#
    theme(plot.title = element_text(lineheight=.8), panel.margin = unit(c(0.5,0,0,0),"in"),plot.margin = unit(c(0.1,0,0,0),"in")) # Ajuste les marges du graphiques
getwd()
load("RandomForest_temp.rObj")
